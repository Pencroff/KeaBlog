<!DOCTYPE html>
<html>
<head>
    <title>Example CKEditor</title>
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet" type="text/css"/>
    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="ckeditor.js"></script>
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="span8 offset2">
                <div class="page-header pagination-centered">
                    <h1>Example &laquo;CKEditor&raquo;</h1>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="span12">
                <textarea id="ckeditor-area" class="span9"><p><img alt="IEnumerable VS IList VS IQueryable" src="http://2.bp.blogspot.com/-U3n32jg27U8/URQXX4qguaI/AAAAAAAABf8/dwLzYBwStKQ/s1600/ICollection.png" style="width: 404px; height: 297px; margin: 10px; float: left;" /><span style="font-size:18px;"><span style="font-family:georgia,serif;">Yes, both will give you deferred execution. The difference is that IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> is the interface that allows LINQ-to-SQL (LINQ.-to-anything really) to work. So if you further refine your query on an IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;">, that query will be executed in the database, if possible. For the IEnumerable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> case, it will be LINQ-to-object, meaning that all objects matching the original query will have to be loaded into memory from the database. In code: IQueryable</span></span><customer><span style="font-size:18px;"><span style="font-family:georgia,serif;"> custs = ...; // Later on... var goldCustomers = custs.Where(c =&gt; c.IsGold);</span></span> </customer></t></t></t></p>

<div id="cut">&nbsp;</div>

<p><span style="font-size:18px;"><span style="font-family:georgia,serif;">That code will execute SQL to only select gold customers. The following code, on the other hand, will execute the original query in the database, then filtering out the non-gold customers in the memory: IEnumerable</span></span><customer><span style="font-size:18px;"><span style="font-family:georgia,serif;"> custs = ...; // Later on... var goldCustomers = custs.Where(c =&gt; c.IsGold); This is quite an important difference, and working on IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> can in many cases save you from returning too many rows from the database. Another prime example is doing paging: If you use Take and Skip on IQueryable, you will only get the number of rows requested; doing that on an IEnumerable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> will cause all of your rows to be loaded in memory.</span></span></t></t></customer></p>

<div>
<p>&nbsp;</p>
</textarea>
                <script type="text/javascript">
                    //<![CDATA[
                    CKEDITOR.replace( 'ckeditor-area', {
                        //skin : 'BootstrapCK-Skin'
                    });
                    //]]>
                </script>
            </div>
        </div>
        <br>
        <div class="row">
            <div class="span12">
                <p><img alt="IEnumerable VS IList VS IQueryable" src="http://2.bp.blogspot.com/-U3n32jg27U8/URQXX4qguaI/AAAAAAAABf8/dwLzYBwStKQ/s1600/ICollection.png" style="width: 404px; height: 297px; margin: 10px; float: left;" /><span style="font-size:18px;"><span style="font-family:georgia,serif;">Yes, both will give you deferred execution. The difference is that IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> is the interface that allows LINQ-to-SQL (LINQ.-to-anything really) to work. So if you further refine your query on an IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;">, that query will be executed in the database, if possible. For the IEnumerable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> case, it will be LINQ-to-object, meaning that all objects matching the original query will have to be loaded into memory from the database. In code: IQueryable</span></span><customer><span style="font-size:18px;"><span style="font-family:georgia,serif;"> custs = ...; // Later on... var goldCustomers = custs.Where(c =&gt; c.IsGold);</span></span> </customer></t></t></t></p>

<div id="cut">&nbsp;</div>

<p><span style="font-size:18px;"><span style="font-family:georgia,serif;">That code will execute SQL to only select gold customers. The following code, on the other hand, will execute the original query in the database, then filtering out the non-gold customers in the memory: IEnumerable</span></span><customer><span style="font-size:18px;"><span style="font-family:georgia,serif;"> custs = ...; // Later on... var goldCustomers = custs.Where(c =&gt; c.IsGold); This is quite an important difference, and working on IQueryable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> can in many cases save you from returning too many rows from the database. Another prime example is doing paging: If you use Take and Skip on IQueryable, you will only get the number of rows requested; doing that on an IEnumerable</span></span><t><span style="font-size:18px;"><span style="font-family:georgia,serif;"> will cause all of your rows to be loaded in memory.</span></span></t></t></customer></p>

<div>
<p>&nbsp;</p>


            </div>
        </div>
    </div>
    <script type="text/javascript">
        //SyntaxHighlighter.all()
    </script>
</body>
</html>